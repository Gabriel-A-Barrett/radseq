include { FASTQ_ALIGN_BWA                        } from '../nf-core/fastq_align_bwa/main'
include { SAMTOOLS_INDEX as SAMTOOLS_INDEX_CRAM  } from '../../modules/nf-core/samtools/index/main'
include { BWA_INDEX                              } from '../../modules/nf-core/bwa/index'

workflow FASTQ_INDEX_ALIGN_BWA_MINIMAP {

    take:
    reads
    fasta
    sequence_type
    read_lengths

    main:
    ch_versions = Channel.empty()

    BWA_INDEX ( fasta )

    ch_reads_index_fasta = fasta
        .join(BWA_INDEX.out.index, by: [0])
        .combine(reads)
        .map { meta, fasta, index, meta2, reads ->
        [[id:meta2.id, single_end:meta2.single_end, ref_id:meta.ref_id], reads, index, fasta]
        }

    cram_crai_fasta = FASTQ_ALIGN_BWA ( ch_reads_index_fasta, fasta, sequence_type, read_lengths ).cram_crai_fasta

    // add per-individual mapping rates to end of channel
    if (params.check_alignment_mapping_rates) {
        FASTQ_ALIGN_BWA.out.flagstat.map { WorkflowRadseq.getCramPercentMapped(params,it) }.set{ ch_percent_mapped }
    }

    // remove files that didn't make the threshold in params
    cram_crai_fasta.join(ch_percent_mapped, by: [0]).map { meta, cram, crai, fasta, mapped, pass -> if (pass) [meta,cram,crai] }.set { cram_crai_filtered }

    mcram_crai = CRAM_MERGE_INDEX_SAMTOOLS (cram_crai_filtered.map{meta,cram,crai -> [meta, cram]}, fasta, fai).cram_crai
    ch_versions = ch_versions.mix( CRAM_MERGE_INDEX_SAMTOOLS.out.versions )

    //
    // Groovy function appends mismatch_rate and primary_paired to meta for filtering by .min{}
    //
    if (params.method == 'denovo' && params.only_use_best_reference) {
        mcram_crai_fasta = mcram_crai.combine(fasta, by: [0])

        SAMTOOLS_STATS ( mcram_crai_fasta )

        mcram_crai = mcram_crai.join(SAMTOOLS_STATS.out.stats, by:0)
            .map {
                WorkflowRadseq.selectBestPsuedoReference(it[0],it[1],it[2],it[3])
            }
            .min{it[0].mismatch_error}
            .map { meta, mcram, crai -> 
                def metaf = [:]
                metaf.id = meta.id
                metaf.single_end = meta.single_end
                metaf.ref_id = meta.ref_id

                return [metaf, mcram, crai]
            }
    }

        //.map {
        //    WorkflowRadseq.selectBestPsuedoReference(it)
        //}

    emit:
    //cram      = cram_crai_filtered.map{meta,cram,crai -> [meta, cram]}
    cram_crai    = FASTQ_ALIGN_BWA.out.cram_crai
    ch_cram_crai = FASTQ_ALIGN_BWA.out.cram_crai_fasta
    //mcram_crai
    stats        = FASTQ_ALIGN_BWA.out.stats
    flagstat     = FASTQ_ALIGN_BWA.out.flagstat
    idxstats     = FASTQ_ALIGN_BWA.out.idxstats
    
    versions = ch_versions
}