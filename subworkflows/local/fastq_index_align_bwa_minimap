include { BWA_INDEX                              } from '../../modules/nf-core/bwa/index'
include { FASTQ_ALIGN_BWA                        } from '../nf-core/fastq_align_bwa/main'
include { SAMTOOLS_INDEX as SAMTOOLS_INDEX_CRAM  } from '../../modules/nf-core/samtools/index/main'
include { BAM_MERGE_INDEX_SAMTOOLS as CRAM_MERGE_INDEX_SAMTOOLS } from '../local/bam_merge_index_samtools'
include { SAMTOOLS_STATS as DENOVO_REFERENCE_CRAM_STATS } from '../../modules/nf-core/samtools/stats/main'

workflow FASTQ_INDEX_ALIGN_BWA_MINIMAP {

    take:
    reads
    fasta
    fai
    sequence_type
    read_lengths

    main:
    ch_versions = Channel.empty()

    BWA_INDEX ( fasta )

    ch_reads_index_fasta = fasta
        .join(BWA_INDEX.out.index, by: [0])
        .combine(reads)
        .map { meta, fasta, index, meta2, reads ->
        [[ id:meta2.id, single_end:meta2.single_end, ref_id:meta.ref_id ], reads, index, fasta ]
        }

    cram_crai_fasta = FASTQ_ALIGN_BWA ( ch_reads_index_fasta, fasta, sequence_type, read_lengths ).cram_crai_fasta

    // add per-individual mapping rates to end of channel
    if (params.check_alignment_mapping_rates) {
        FASTQ_ALIGN_BWA.out.flagstat.map { WorkflowRadseq.getCramPercentMapped(params,it) }.set{ ch_percent_mapped }
    }

    // remove files that didn't make the threshold in params
    cram_crai_fasta.join(ch_percent_mapped, by: [0]).map { meta, cram, crai, fasta, mapped, pass -> if (pass) [meta,cram,crai,fasta] }.set { cram_crai_fasta_filtered }
    
    mcram_crai = CRAM_MERGE_INDEX_SAMTOOLS (cram_crai_fasta_filtered.map{meta,cram,crai,fasta -> [meta, cram]}, fasta, fai).mcram_crai
    ch_versions = ch_versions.mix( CRAM_MERGE_INDEX_SAMTOOLS.out.versions )

    //
    // Groovy function appends mismatch_rate and primary_paired to meta for filtering by .min{}
    //
    if (params.method == 'denovo' && params.only_use_best_reference) {
        mcram_crai_fasta = mcram_crai.combine(fasta, by: [0])

        DENOVO_REFERENCE_CRAM_STATS ( mcram_crai_fasta )

        mcram_crai = mcram_crai.join(DENOVO_REFERENCE_CRAM_STATS.out.stats, by:0)
            .map {
                WorkflowRadseq.selectBestPsuedoReference(it[0],it[1],it[2],it[3])
            }
            .min{it[0].mismatch_error}
            .map { meta, mcram, crai -> 
                def metaf = [:]
                metaf.id = meta.id
                metaf.single_end = meta.single_end
                metaf.ref_id = meta.ref_id

                return [metaf, mcram, crai]
            }
    }

        //.map {
        //    WorkflowRadseq.selectBestPsuedoReference(it)
        //}

    emit:
    cram            = cram_crai_fasta_filtered.map{meta,cram,crai,fasta -> [meta, cram]}
    cram_crai       = FASTQ_ALIGN_BWA.out.cram_crai
    cram_crai_fasta = cram_crai_fasta_filtered
    mcram_crai
    stats           = FASTQ_ALIGN_BWA.out.stats
    flagstat        = FASTQ_ALIGN_BWA.out.flagstat
    idxstats        = FASTQ_ALIGN_BWA.out.idxstats
    
    versions = ch_versions
}