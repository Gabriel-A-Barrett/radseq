//
// Align reads w/ BWA or MINIMAP
//

include { BWA_INDEX                } from '../../modules/nf-core/bwa/index/main.nf'
include { BWA_MEM                  } from '../../modules/nf-core/bwa/mem/main.nf'
//include { MINIMAP_INDEX          } from '../../modules/nf-core/minimap/index/main.nf'
include { MINIMAP2_ALIGN           } from '../../modules/nf-core/minimap2/align/main.nf'
include { UMITOOLS_DEDUP           } from '../../modules/nf-core/umitools/dedup/main.nf'
include { SAMTOOLS_INDEX           } from '../../modules/nf-core/samtools/index/main.nf'
include { BAM_STATS_SAMTOOLS       } from '../nf-core/bam_stats_samtools/main.nf'
include { BAM_MERGE_INDEX_SAMTOOLS } from '../nf-core/bam_merge_index_samtools/main.nf'


workflow FASTQ_INDEX_ALIGN_BWA_MINIMAP {

    take:
    reads
    fasta
    fai
    sort_view
    sequence_type
    read_lengths

    main:
    ch_versions = Channel.empty()

    switch ( params.aligner ) {

        case 'bwa': 

            BWA_INDEX (fasta)
            ch_versions = ch_versions.mix(BWA_INDEX.out.versions)

            // add specific arguments 
            bam = BWA_MEM (reads, BWA_INDEX.out.index.first(), sort_view, sequence_type, read_lengths.collect()).bam
            ch_versions = ch_versions.mix(BWA_MEM.out.versions)
                break
        
        case 'minimap2':

            //MINIMAP_INDEX ()
            //ch_versions = ch_versions.mix(MINIMAP_INDEX.out.versions)

            bam = MINIMAP2_ALIGN (reads, fasta.first(), true, false, false).bam
            ch_versions = ch_versions.mix(MINIMAP_ALIGN.out.versions)
                break

        case 'bwa2':

            BWA2_INDEX (fasta)
            ch_versions = ch_versions.mix(BWA2_INDEX.out.versions)

            // add specific arguments 
            bam = BWA2_MEM (reads, BWA2_INDEX.out.index.first(), sort_view, type).bam
            ch_versions = ch_versions.mix(BWA2_MEM.out.versions)
                break
    }

    // split up into 2 channels to decide input for deduplication
    bam_to_umi = bam
        .branch { meta, bam ->
            umi: meta.umi_barcodes == true
            no_umi: meta.umi_barcodes == false
        }

    // query only reads that satisfied the above condition
    umi_bam = UMITOOLS_DEDUP (bam_to_umi.umi, false)

    bai = SAMTOOLS_INDEX (bam_to_umi.no_umi.mix(umi_bam)).bai
    ch_versions = ch_versions.mix(SAMTOOLS_INDEX.out.versions)

    // add deduplicated umi reads to no_umi channnel and join the index's
    bam_bai = bam_to_umi.no_umi
        .mix(umi_bam)
        .join(bai)

    // get statistics
    BAM_STATS_SAMTOOLS (bam_bai, fasta.map{it[1]}.first())
    ch_versions = ch_versions.mix(BAM_STATS_SAMTOOLS.out.versions)

    mbam_bai = BAM_MERGE_INDEX_SAMTOOLS (bam_bai.map{meta,bam,bai -> [meta, bam]}, fasta.map{it[1]}.first(), fai.map{it[1]}.first()).bam_bai
    ch_versions = ch_versions.mix(BAM_MERGE_INDEX_SAMTOOLS.out.versions)

    emit:
    bam_bai
    mbam_bai
    stats    = BAM_STATS_SAMTOOLS.out.stats
    flagstat = BAM_STATS_SAMTOOLS.out.flagstat
    idxstats = BAM_STATS_SAMTOOLS.out.idxstats
    
    versions = ch_versions
}